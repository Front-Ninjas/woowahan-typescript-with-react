# 12장 타입스크립트 프로젝트 관리
## 12.1 Ambient 타입 활용하기

### 12.1.1 Ambient 타입 선언
TS의 컴파일러에게 타입 정보를 알려주거나 확장하기 위해 사용하는 방법.
- .d.ts 확장자를 가진 파일에서 하는 타입 선언을 말함.
- Ambient 타입 선언으로 값을 정의할 수는 없지만 declare라는 키워드를 사용하여 어딘가에 값이 존재한다는 사실을 선언할 수 있음.

**자바스크립트로 작성된 라이브러리**
타입 선언이 존재하지 않아 임포트한 모듈은 모두 any로 추론될 것이다. 만약 tsconfig.json 설정으로 any를 사용하지 못하게 설정했다면 프로젝트가 빌드되지 않을 것이다.
- 이때 앰비언트 타입을 사용하여 해당 라이브러리의 타입 정보를 TypeScript에 제공할 수 있다.
- .d.ts 확장자를 가진 파일을 검색하여 타입 검사를 진행하게 되므로 문제없이 컴파일 된다.
- **Ambient 타입 선언은 TS에게 JS코드 안에는 이러한 정보들이 있어라고 알려주는 도구**이다.


**타입스크립트로 작성된 라이브러리**
배포할 때엔 JS파일과 .d.ts 파일로 배포하는 것이 일반적이다. 
- 별도로 컴파일을 하지 않아도 되기 때문에 컴파일 시간을 줄일 수 있다.
- .d.ts 파일에 정의된 타입 정보를 활용하여 라이브러리를 사용할 수 있다.

**JS 어딘가에 전역 변수가 정의되어 있음을 TS에게 알릴 때**
실제 자바스크립트 어딘가에 전역 변수가 정의되어 있는 상황을 타입스크립트에게 알릴 때 Ambiet 타입 선언을 사용한다.

### 12.1.2 Ambient 타입 선언 시 주의점
- 타입스크립트로 만드는 라이브러리에는 불필요
  - tsconfig.json의 declaration을 true를 설정하면 타입스크립트 컴파일러가 .d.ts파일을 자동으로 생성해줌.
  - 수동으로 .d.ts 파일을 작성할 필요가 없음.
- 전역으로 타입을 정의하여 사용할 때 주의할 점
  - 서로 다른 라이브러리에서 동일한 이름의 Ambient 타입 선언 -> 충돌 발생, 어떤 타입 선언이 적용될지 알기 어려움, 의도한대로 동작하지 않을 수 있음.
  - import, export 등을 하지 않고 사용하기 때문에 코드의 의존성 관계가 명확하지 않아 나중에 변경할 때 어려울 수 있음.
  
### 12.1.3 Ambient 타입 선언을 잘못 사용했을 때의 문제점
- .ts 파일 내에서 Ambient 타입 선언은 개발자에게 혼란을 야기함.
  - import, export 등을 하지 않고 사용하기 때문에 **코드의 의존성 관계가 명확하지 않기** 때문에 **변경에 의한 영향 범위를 파악하기 어려움**.
  - .d.ts 파일 이외에서 Ambient 타입 선언은 일반 타입 선언과 섞이게 되면 Ambient 선언이 어떤 파일에 포함되어 있는지 파악하기 어려워 유지보수를 어렵게 만듦.
### 12.1.4 Ambient 타입 활용하기
- .d.ts 파일에서 Ambient 타입 선언은 전역 변수와 같은 역할을 한다.
  - 모든 코드 내에서 import하지 않고 사용할 수 있음.
  - 유틸리티 타입을 선언하면 모든 코드에서 바로 사용할 수 있음. 
- declare type 활용하기
  ```jsx
  declare type Nullable<T> = T | null;
  const name:Nullable<string> = 'woowa';
  ```
- declare module 활용하기
  ```jsx
  const fontSize = {
    xl: '30px',
    //...
  };
  
  const colors = {
    gray_100: '#222222',
    gray_200: '#444444',
    //...
  };
  
  const depths = {
    origin: 0,
    foreground: 10,
    dialog: 100,
    //...
  };
  
  const theme = {
    fontSize,
    colors,
    depths
  };
  //기존의 모듈을 확장하여 추가적인 타입을 정의할 수 있다.
  // 이를 통해 기존에 정의한 theme 객체의 타입이 자동으로 완성되는 기능을 지원
  declare module 'styled-components' {
    type Theme = typeof theme;
    export interface DefaultTheme extends Theme {};
  }
  // 로컬 이미지나 SVG 같이 외부로 노출되어 있지 않은 파일을 모듈로 인식하여 사용할 수 있게끔 만들 수 있음.
  declare module '*.gif' {
    const src: string;
    export default src;
  }
  ```
- declare namespace 활용하기
  ```jsx
  // Node.js 환경에서 .env 파일을 사용할 때 declare namespace를 활용하여 process.env로 설정값을 손쉽게 불러오고
  // 환경 변수의 자동 완성 기능을 쓸 수 있다.
  declare namespace NodeJS {
    interface ProcessEnv {
      readonly API_URL: string;
      readonly API_INTERNAL_URL: string;
      // ...
    }
  }
  // process.env를 통해 접근하는 변수 또한 타입을 지정할 수 있기 때문에
  // as 단언을 사용하지 않아도 타입이 보강되어 추론이 가능해진다.
  // .env 파일
  API_URL = 'localhost:8080';
  
  // d.ts 파일
  declare namespace NodeJS {
    interface ProcessEnv{
      readonly API_URL: string;
    }
  }
  
  console.log(process.env.API_URL); // as 단언없이 string 타입으로 추론된다.

  ```
- declare global 활용하기
  - 전역 객체에 새로운 속성을 추가하거나, 기존 속성의 타입을 수정하는데 사용한다.
    ```jsx
    decalre global {
      interface Window {
        newProperty: string;
      }
    }
    ```
  - 대표적으로 네이티브 앱과의 통신을 위한 인터페이스를 Window 객체에 추가할 때 Ambient 타입 선언을 활용할 수 있다.
    ```jsx
    decalre global {
      interface Window {
        webkit?: {
          messageHandlers?: Record<string, {postMessage?: (parameter: string) => void;}>
        }
      }
    }
    ```
### 12.1.5 declare와 번들러의 시너지
declare global로 전역 변수를 선언하는 과정과 번들러를 통해 데이터를 주입하는 절차를 함께 활용하면 시너지를 낼 수 있다.
```jsx
const color = {
  white: '#ffffff',
  black: '#000000',
} as const;

type ColorSet = typeof color;

declare global {
  const _color: ColorSet;
}
```
- _color라는 변수가 존재함을 TS 컴파일러에 알리면 해당 객체를 활용할 수 있게 되지만 해당 변수가 ColorSet 타입을 가지는 정보를 가지고 있을 뿐 실질적인 데이터가 존재하지 않음.
  - TS는 에러를 발생시키지 않지만, 코드가 실행될 경우에는 실제 데이터가 없기 때문에 기대하는 동작과 다를 수 있다.
- 해결 : 번들 시점에 번들러를 통해서 해당 데이터를 주입하는 것
  - rollup 번들러의 inject 모듈로 데이터를 주입하는 예시
  ```jsx
  // data.ts
  const color = {
    white: '#ffffff',
    black: '#000000',
  } as const;
  
  // type.ts
  import { color } from './data';
  
  type ColorSet = typeof color;
  declare global {
    const _color: ColorSet;
  }
  
  // index.ts
  console.log(_color['white']);
  
  // rollup.config.js
  import inject from '@rollup/plugin-inject';
  import typescript from '@rollup/plugin-typescript';

  // rollup 번들러 설정에서 inject 모듈을 사용하여 _color에 해당하는 데이터를 삽입하고 있다.
  export default [
    {
      input: 'index.ts',
      output: [
        {
          dir: 'lib',
          format: 'esm'
        }
      ],
      plugins: [typescript(), inject({ _color: ['./data', 'color'] })],
    }
  ];
  ```

## 12.2 스크립트와 설정 파일 활용하기
스크립트와 tsconfig 등을 잘 활용하면 개발 생산성을 높일 수 있다.

### 12.2.1 스크립트 활용하기
**실시간으로 타입을 검사하자**
- `yarn tsc -noEmit -incremental -w`
  - noEmit 옵션은 JS파일을 생성하지 않도록 설정
  - incremental 옵션은 증분 컴파일을 활성화하여 컴파일 시간을 단축
    - 증분 컴파일 : 변경 사항이 있는 부분만을 컴파일하는 것을 말하며, 불필요한 컴파일을 줄여 컴파일 시간을 줄일 수 있음
  - w는 watch로 파일 변경 사항을 모니터링하도록 활성화하는 옵션
- 실행하면 파일이 변경될 때마다 tc가 실행되어 어디에서 타입 에러가 발생했는지를 실시간으로 추적할 수 있음.

**타입 커버리지 확인하기**

현재 프로젝트에서 얼마나 타입스크립트를 적절하게 쓰고 있는지, 타입 적용 범위를 알기 위해 타입 커버리지 기능을 사용할 수 있다. 
- `npx type-coverage -detail`
- 실행하면 현재 프로젝트의 타입 커버리지와 any를 사용하고 있는 변수의 위치가 나타남.

타입스크립트로 마이그레이션 중인 프로젝트나 레거시 코드가 많은 프로젝트를 다룰 때 타입 커버리지를 체크함으로써 더 나은 코드 퀄리티로 리팩터링하기 위한 기반을 마련하는 데 도움이 되는 정략적인 지표를 얻을 수 있다.

### 12.2.2 설정파일 활용하기
**타입스크립트 컴파일 속도 높이기**
 incremental 옵션을 tsconfig에서 직접적으로 설정할 수 있다. 
 - true로 변경하면 증분 컴파일이 활성화되어 변경된 부분만 컴파일하게 된다.
### 12.2.3 에디터 활용하기
**에디터에서 타입스크립트 서버 재시작하기**
때로는 정의된 타입이 있는 개체인데도 import되지 않거나 자동 완성 기능이 동작하지 않는 경우를 종종 볼 수 있다.
- 이런 상황에서 타입스크립트 서버를 재실행하면 된다.
- VSCode에서 Restart TS server 기능을 지원
- 윈도우: ctrl+ shift + p, 맥: command + shift + p를 누르고 실행


## 12.3 타입스크립트 마이그레이션
### 12.3.1 타입스크립트 마이그레이션의 필요성
상황에 따라 비즈니스 요구 사항의 변화를 반영할 수 있는 새로운 설계를 기반으로 타입을 작성하는게 효율적일 수 있다. 
- 기존 프로젝트를 신규 프로젝트로 바꾸는게 나을지 단순히 마이그레이션하는 게 나을지를 신중하게 따져봐야 한다.
### 12.3.2 점진적인 마이그레이션
작은 부분부터 시작하여 점차 범위를 넓혀가며 마이그레이션을 진행한다. 
- 진입 장벽이 낮아짐
- 프로젝트 전반적인 동작을 안정적으로 유지할 수 있게 됨.

단순히 allowJS: true, noImplicitAny: false로 설정한 채 무기한으로 마이그레이션을 미루는 것은 지양해야 함.
- 점진적인 마이그레이션을 진행한다면, 프로젝트 참여자와 우선순위를 대략적이라도 설정해두면 좋음.
### 12.3.3 마이그레이션 진행하기
- TS 개발 환경 설정, 빌드 파이프라인에 TS 컴파일러를 통합한다.
  - tsconfig.json 파일에서 allowJS: true, noImplicitAny: false로 설정
  - allowJS: 기본값은 false로 자바스크립트 파일을 컴파일할 때 사용하는 옵션 (JS코드에서 TS코드를 혼합하여 사용하는 것을 허락)
  - noImplicitAny : 암시적 any 타입의 허용 여부를 설정하는 옵션
- 작성된 JS 파일을 TS 파일로 변환한다. 필요한 타입과 인터페이스를 하나씩 정의하며 함수 시그니처를 추가해 나간다.
- 작업이 완료되었다면 tsconfig.json 파일에서 allowJS: false, noImplicitAny: true로 재설정 한다.

## 12.4 모노레포
모노레포란? “Monolithic Repository”의 줄임말로, 여러 프로젝트와 모듈을 하나의 대형 코드 저장소에 통합하는 방식을 의미한다.
### 12.4.1 분산된 구조의 문제점
독립적인 프로젝트에서 다른 프로젝트가 가진 기능이 필요하다면, 단순히 해당 기능을 복사하여 붙여넣기함으로써 빠르게 구현할 수 있음.
- 복사한 코드에 버그가 있거나 기능 확장을 위해 수정해야할 때 프로젝트의 개수만큼 반복적인 수정 작업을 해야 함.
- 특정 라이브러리에 문제가 생기거나 더 이상 사용하지 않는 경우에도 모드 프로젝트에 일일이 대응해야 함.
- 따라서 개발자가 변경이 필요한 지점을 모두 인지하고 있어야 하기 때문에 개발자 경험(DX)이 저해될 수 있음.
- 장기적으로도 프로젝트 관리가 어려워지면서 업무 효율이 갈수록 악화되는 현상이 발생

=> 분산된 구조는 생산성을 떨어뜨리는 결과를 초래한다. 따라서 **한 곳에서 프로젝트를 관리할 수 있도록 통합해야 한다.**
### 12.4.2 통합할 수 있는 요소 찾기
- 먼저 독립적인 프로젝트 내에 공통으로 통합할 수 있는 요소를 찾아야 한다. 
- 일부 파일의 소스코드가 같지 않다면 통합을 위해 일부 수정할 수도 있다.
### 12.4.3 공통 모듈화로 관리하기
소스코드를 수정한 다음에 모듈화를 통해 통합할 수 있다. 
- npm과 같은 패키지 관리자를 활용하여 공통 모듈을 생성하고 관리
- 각 프로젝트에서 간편하게 모듈과 의존성을 맺고 사용할 수 있게 됨.

장점
- 새로운 프로젝트를 생성하더라도 모듈을 통해 코드를 재사용할 수 있음
- 특정 기능의 변경이 필요할 때는 해당 모듈의 소스코드만 수정하면 되기 때문에 유지보수도 쉬워짐.

아쉬운 점
- 공통 모듈에 변경이 발생한다면, 해당 모듈을 사용하는 프로젝트에서도 추가적인 작업이 필요할 수 있음.
- 공통 모듈의 개수가 늘어나면 관리해야할 레포지토리도 그만큼 늘어남.

### 12.4.4 모노레포의 탄생
모노레포(Monorepo)란 버전 관리 시스템에서 여러 프로젝트를 하나의 레포지토리로 통합하여 관리하는 소프트웨어 개발 전략이다. 

- 모노레포 이전에는 모놀리식 기법을 주로 사용함
  - 모놀리식 기법 : 다양한 기능을 가진 프로젝트를 하나의 레포지토리로 관리하는 방식
- 모놀리식 구조의 문제점
  - 코드간의 직접적인 의존 발생 -> 일부 로직만 변경될 떄도 전체 프로젝트에 영향을 줄 수 있음.
  - 설계적인 측면과 빌드 빛 배포 등에서 효율적이지 못함.
- 효율적인 구조에 대한 수요로 폴리레포 방식과 모노레포 방식 등장
  - 폴리레포 방식 : 거대한 프로젝트를 작은 프로젝트의 집합으로 나누어 관리하는 방식
 
모노레포를 사용하면 개발 환경 설정도 통합할 수 있어서 더 효율적인 관리가 가능해진다.
- 장점
  - Lint, CI/CD 등 개발 환경 설정을 통합적으로 관리하기 때문에 불필요한 코드 중복을 줄여준다.
  - 공통 모듈이 동일한 프로젝트 내에서 관리되므로, 별도의 패키지 관리자를 통해 모듈을 관리하지 않아도 된다.
    - 이에 따라 기능 변화를 쉽게 추적하고 의존성을 관리할 수 있다.
- 단점
  - 레포지토리가 거대해질 수 있다.
  - 여러 팀의 이해관계가 얽혀 소유권과 권한 관리가 복잡해질 수 있다.
  - 여러부서에서 관리하다 보니 깃 로그를 읽고 변경 내역을 빠르게 파악하기 어렵다.
