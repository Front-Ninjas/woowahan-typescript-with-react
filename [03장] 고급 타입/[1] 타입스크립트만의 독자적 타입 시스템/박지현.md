## 고급 타입 
### 타입스크립트 만의 독자적인 타입 시스템
타입스크립트의 타입 시스템이 내포하고 있는 개념은 모두 자바스크립트에서 기인한 것으로 자바스크립트로 표현할 수단과 필요성이 없었을 뿐이다.
자바스크립트의 슈퍼셋으로 정적 타이핑이 가능한 타입스크립트가 등장하면서 비로소 타입스크립트의 타입 시스템이 구축되었다.
### any타입
어떠한 값을 할당하더라도 오류가 나지않는다.
정적타이핑의 기능을 무색하게 만들어 지양된다.
꼭 필요한 경우가 있다.
**개발 단계에서 임시로 값을 지정해야 할 때**
**어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을때**
**값을 예측할 수 없을 때 암묵적으로 사용**
이렇게 예외적인 상황이 있지만 그럼에도 any타입은 지양하는게 좋다.
### unknown 타입
any 타입과 유사하게 모든 타입의 값이 할당될 수 있지만 다른 타입으로 할당이 불가능하다.
```javascript
  const unknownFunction: unknown : () => console.log("야호"); // 에러 안남
  unknownFunction(); // 에러 발생
```

개발자가 엄격한 타입 검사를 강제하도록 의도한다. any 대신 unknown이 권장된다.

### void 타입
함수가 아무런 값을 반환하지 않는 경우에 매핑하는 타입.
함수 자체를 다른 함수의 인자로 전달하는 경우가 아니라면 void 타입은 잘 명시 하지 않는다.
타입스크립트 컴파일러가 알아서 함수 타입을 void로 추론하기 때문이다.

### never 타입
never 함수와 관련해서 많이 사용되는 타입.
값을 반환하지 않는 것이 아닌 값을 반환할 수 없는 경우다.
값을 반환할 수 없는 **에러를 던지는 경우** ,**무한히 함수가 실행되는 경우** 이런 경우에 사용한다.

### Array 타입
객체의 타입을 알아내는데 사용하는 함수 Object.prototype.toString.call()
typeof는 []를 object로 알려주지만 Object.prototype.toString.call([])는 객체의 인스턴스까지 알려줘 객체의 타입을 알 수 있다.
자바스크립트에서도 확인할 수 있지만 자바스크립트는 배열을 배열이라는 단독 자료형이 아닌 객체에 속하는 타입으로 분류한다. 
그래서 타입스크립트에서 Array 키워드 혹은 []로 관리할 수 있다.
```javascript
  const arr1 : Array<number | string> = [1, "string"]
  const arr1 : [number, string] = [1, "string"] // 튜플 2개만 올 수 있고 자리도 정해져있다. 
  const arr1 : [number, string, number?] = [1, "string"] // 옵셔널도 가능   
```
튜플은 배열 원소의 명확한 의미와 쓰임을 보장할 때 더욱 안전하게 사용할 수 있는 타입이다.

### enum 타입
열거형이라고 불리며 타입스크립트에서 지원하는 특수 타입이다.
```javascript
  const enum 저녁밥 { 햄버거, 피자 }
  저녁밥 = 200 // 에러가 안남
  저녁밥.햄버거 // 0 //
  
  enum ProgrammingLanguage {
    TypeScript = "Typescript"
    Javascript = "Javascript"
    Java = 300
    Python // 301
  }
```
주로 문자열 상수를 생성하는데 사용된다. ProgrammingLanguage을 매개변수로 넘기면 열거형에 저장된 모든 멤버를 사용할 수 있다.
열거형을 사용할 떄 주의할 점은 숫자로만 이루어지면 타입스크립트가 자동으로 추론하여 예측과 다른 결과를 낳을 수 있다. 예를 들면 역방향 접근
이러한 동작을 const enum으로 하면 역방향으로의 접근은 허용하지 않는다. 
그러나 const enum도 숫자 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 때 이를 방지하지 못한다.
그래서 문자열 상수 방식으로 사용하는 것이 좋다.
일부 번들러는 트리쉐이킹 과정 중 즉시 실행 함수로 변환되 것을 사용하지 않는 코드로 인식하지 못해 불필요한 코드 증가가 있을 수 있다.
