# 9.1 리액트 훅
리액트 훅이 도입되면서 클래스 컴포넌트 뿐만 아닌 함수 컴포넌트도 컴포넌트의 생명주기를 활용할 수 있게 되었다.

 이를 통해 코드를 작게 분할하여 테스트하는 게 용이해지고, 사이드 이펙트와 상태를 관심사에 맞게 분리하여 구성할 수 있게 되었다.

## 9.1.1 useState

```tsx
function useState<S>(
  initialState: S | (() => S)
): [S, Dispatch<SetStateAction<S>>];

type Dispatch<A> = (value: A) => void;
type SetStateAction<S> = S | ((prevState: S) => S);
```

useState를 동기적으로 처리하기 위해 튜플의 두 번째 요소는 상태를 업데이트할 수 있는 Dispatch 타입의 함수를 사용한다.
Dispatch 함수의 제네릭인 SetStateAction에는 상태 타입인 S나 새로운 상태를 반환하는 함수인 (prevState: S) => S가 들어갈 수 있다.

```tsx
import { useState } from 'react';

interface Member {
 name: string;
 age: number;
}

const MemberList = () => {
 const [memberList, setMemberList] = useState<Member[]>([]);
 
 const sumAge = memberList.reduce((sum, member) => sum + member.age, 0);
 
 const addMember = () => {
  setMemberList([
   ...memberList,
   {
    name: 'DokgoBaedal',
    agee: 11,
   },
  ]);
 };
 
 return ();
};
```

useState에 TypeScript를 적용하면 기존 배열 요소에 없는 잘못된 속성을 포함하는 객체를 투입했을 때 NaN으로 출력되어 이유를 찾기 어려운 오류가 발생하는 것을 막을 수 있다.
