# 9장 훅
## 9.1 리액트 훅
리액트 훅 도입 전
- 클래스 컴포넌트에서만 상태를 가질 수 있었다.
  - 하나의 생명주기 함수에서만 상태 업데이트에 따른 로직을 실행시킬 수 있었다.
- 프로젝트 규모가 커지면서 상태를 스토어에 연결하거나 비슷한 로직을 가진 상태 업데이트 및 사이드 이펙트 처리가 불편해졌다.
- 모든 상태를 하나의 함수 내에서 처리해야 했다.
  - 관심사가 뒤섞여 상태에 따른 테스트나 잘못 발생한 사이드 이펙트 디버깅이 어려웠다.

리액트 훅 도입 후
- 함수 컴포넌트에서도 컴포넌트의 생명주기에 맞춰 로직을 실행할 수 있게 되었다.
- 비즈니스 로직을 재사용하거나 작은 단위로 코드를 분할하여 테스트하는게 용이해 졌다.
- 사이드 이펙트와 상태를 관심사에 맞게 분리하여 구성할 수 있게 되었다.

### 9.1.1 useState
useState가 반환하는 튜플
- 튜플의 첫번째 요소: 제네릭으로 지정한 S 타입
- 튜플의 두번쨰 요소: 상태를 업데이트할 수 있는 Dispatch 타입의 함수

타입스크립트를 사용하여 상태 타입을 지정해주면 사이드 이펙트 발생을 사전에 방지할 수 있다.
- ex) 잘못된 속성이 포함된 객체가 추가되었을 때 발생하는 에러 방지

### 9.1.2 의존성 배열을 사용하는 훅
**useEffect와 useLayoutEffect**
- 렌더링 이후에 어떤 일을 수행해야 하는지 알려주기 위해 사용
- useEffect
  - 첫번 쨰 인자: effect의 타입인 EffectCallback
    - Destructor 반환 or 아무것도 반환하지 않는 함수
    - Promise 타입은 반환하지 않으므로 콜백함수에는 비동기 함수가 들어갈 수 없다.
    - 비동기 함수를 호출하면 경쟁 상태를 불러일으킬 수 있기 때문이다.
    > **경쟁상태**
    > - 멀티스레딩 환경에서 동시에 여러 프로세스나 스레드가 공유된 자원에 접근하려고 할 때 발생할 수 있는 문제
    > - 실행 순서나 타이밍을 예측할 수 없게 되어 프로그램 동작이 원하지 않는 방향으로 흐를 수 있다.
  - 두번 째 인자: deps
    - 옵셔널하게 제공된다.
    - effect가 수행되기 위한 조건을 나열한다.
    - 주의할 점: 숫자나 문자열 같은 기본형이 아닌 객체나 배열을 넣을때는 주의해야한다.
      - deps가 변경되었는지를 얕은 비교로만 판단하여 실제 객체 값이 변경되지 않아도 객체의 참조값이 변경되면 콜백함수가 실행된다.
      >- 얕은 비교: 원시 자료형은 값을 비교, 참조 자료형(배열, 객체 등)은 값 혹은 속성을 비교하지 않고, 참조되는 위치를 비교
      >- 깊은 비교: Object depth 가 깊지 않은 경우 JSON.stringify() 사용, 깊은 경우 lodash 라이브러리의 isEqual() 사용

  - 반환 값: Destructor
    - 컴포넌트 마운트 해제될 때 실행하는 함수 (클린업 함수)
    - deps가 빈 배열일 경우
      - useEffect의 콜백 함수는 컴포넌트가 처음 렌더링 될 때만 실행되며, Destructor는 컴포넌트가 마운트 해제될때 실행
    - deps 배열이 존재할 경우
      - 배열의 값이 변경될때마다 Destructor 실행
    > **클린업 함수**
    > 컴포넌트가 해제되기 전에 정리 작업을 수행하기 위한 함수
- useLayoutEffect
  - 훅 타입 정의: useEffect와 동일
  - 역할의 차이
    - 화면에 컴포넌트가 그려지기 전에 콜백 함수를 실행하여 **첫번째 렌더링때 빈 상태값이 뜨는 경우를 방지**할 수 있다.
    
**useMemo와 useCallback**
- 이전에 생성된 값 또는 함수를 기억하며, 동일한 값과 함수를 반복해서 생성하지 않도록 해주는 훅
- 어떤 값을 계산하는데 오랜 시간이 걸릴때나 렌더링이 자주 발생하는 form 에서 유용하게 사용할 수 있음
- 주의할 점: deps 에 객체 혹은 배열값 사용할 때
  - 해당 의존성이 변경되면 값을 다시 계산하게 된다.
  - 얕은 비교를 수행하기 때문에 deps 배열이 변경되지 않았는데도 다시 계산 되지 않도록 주의해야 한다.
- 주의할 점: 불필요한 곳에 사용하지 않도록 하는 것
  - 모든 값과 함수를 useMemo와 useCallback을 사용해서 과도하게 **메모이제이션**하면 컴포넌트의 성능 향상이 보장되지 않을 수 있다.
  > **메모이제이션**
  > 이전에 계산한 값을 저장함으로써 같은 입력에 대한 연산을 다시 수행하지 않도록 최적화하는 기술


참고자료
- https://velog.io/@uhuikim/%EC%9A%B0%EC%95%84%ED%95%9C%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-9%EC%9E%A5-%ED%9B%85
