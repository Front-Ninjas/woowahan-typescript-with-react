# 4장 타입 확장하기 좁히기

## 4.2 타입 좁히기 - 타입 가드
변수 또는 표현식의 타입 범위를 더 작은 범위로 좁혀나가는 과정을 말한다.
더 정확하고 명시적인 타입 추론을 할 수 있게 되고, 타입 안정성을 높일 수 있다.
- 4.2.1 타입 가드에 따라 분기 처리하기
  - 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것
  - 타임 가드: 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능
    - 연산자를 활용한 타입 가드: typeof, instanceof, in과 같은 연산자를 사용해서 제어문으로 특정 값을 가질 수 밖에 없는 상황을 유도하여 자연스럽게 타입을 좁히는 방식
    > (자바스크립트 연산자를 사용한 이유: 런타임에도 유효한 타입 가드를 만들기 위해서)
    - 사용자 정의 타입 가드: 사용자가 직접 어떤 타입으로 값을 좁힐지를 지정하는 방식
  - 스코프(scope): 변수와 함수를 선언하거나 사용할 수 있는 영역 (변수와 함수 등의 식별자가 유효한 범위를 나타냄.)

- 4.2.2 워시타입을 추론할 때: typeof 연산자 활용하기
  typeof A === B를 조건으로 분기 처리하면, 해당 분기 내에서는 A의 타입이 B로 추론된다.
   - null, 배열 타입 등이 Object 타입으로 판별되는 등 복잡한 타입을 검증하기에는 한계가 있다.
   - typeof 연산자는 **원시 타입을 판별하는 용도**로만 사용할 것을 권장
   - string, number, boolean, undefined, object, function, bigint, symbol

- 4.2.3 인스턴스화된 객체 타입을 판별할 때: instanceof 연산자 활용하기
instanceof 연산자는 **인스턴스화된 객체 타입을 판별**하는 타입 가드로 사용할 수 있다.
  - A instanceof B 형태: A에는 타입을 검사할 대상 변수, B에는 특정 객체의 생성자가 들어간다.
  - A의 프로토타입 체인에 생성자 B가 존재하는지를 검사해서 존재하면 true, 그렇지 않다면 false를 반환한다.

- 4.2.4 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기
객체에 속성이 있는지 확인한 다음 ture 또는 false를 반환한다. 속성이 있는지 없는지에 따라 객체 타입을 구분할 수 있다.
  - A in B 형태: A라는 속성이 B 객체에 존재하는지 검사
  - true 반환: 프로토타입 체인으로 접근할 수 있는 속성일 때
  - false 반환: delet 연산자를 사용하여 객체 내부에서 해당 속성을 제거했을 때
  - 얼리 리턴: 특정 조건에 부합하지않으면 바로 반환하는 것
 
- 4.2.5 is 연산자로 사용자 정의 타입 가드 만들어 활용하기
직접 타입 가드 함수를 만드는 방식은 반환 타입이 타입 명제인 함수를 정의하여 사용할 수 있다.
  - 타입 명제: A is B 형식 (A는 매개변수 이름, B는 타입)
    - 함수의 반환 타입에 대한 타입 가드를 수행하기 위해 사용되는 특별한 형태의 함수
  - 참/거짓 값을 반환하면서 반환 타입을 타입 명제로 지정하게 되면 **반환 값이 참일 때 A 매개변수의 타입을 B 타입으로 취급**하게 된다.
 

## 4.3 타입 좁히기 - 식별할 수 있는 유니온 (Discriminated Unions)
타입 좁히기에 널리 사용되는 방식이다.

- 4.3.1 에러 정의하기
```jsx
type TextError = {
  errorCode: string;
  errorMessage: string;
};
type ToastError = {
  errorCode: string;
  errorMessage: string;
  toastShowDuration: number; // 토스트를 띄워줄 시간
};
type AlertError = {
  errorCode: string;
  errorMessage: string;
  onConfirm: () => void; // 얼럿 창의 확인 버튼을 누른 뒤 액션
};

type ErrorFeedbackType = TextError | ToastError | AlertError;
const errorArr: ErrorFeedbackType[] = [
  { errorCode: “100”, errorMessage: “텍스트 에러” },
  { errorCode: “200”, errorMessage: “토스트 에러”, toastShowDuration: 3000 },
  { errorCode: “300”, errorMessage: “얼럿 에러”, onConfirm: () => {} },
];

const errorArr: ErrorFeedbackType[] = [
  	// ...
  	{
    	errorCode: "999",
    	errorMessage: "에러",
    	toastShowDuration: 3000,
    	onConfirm: () => {},
  	},
];
```
자바스크립트가 덕 타이핑 언어라는 특징이 있기 때문에 여러 타입이 가지는 속성을 함께 가지도록 작성해도 별도의 타입에러를 뱉지 않는다는 문제가 있다.

- 4.3.2 식별할 수 있는 유니온
각 타입이 비슷한 구조를 가지지만 서로 호환되지 않도록 만들어주기 위해서는 타입들이 서로 포함 관계를 가지지 않도록 정의해야 한다.
  - 정의: 타입 간의 구조 호환을 막기 위해 타입 마다 구분할 수 있는 판별자를 달아주어 포함관계를 제거하는 것이다.
  - ```jsx
    type TextError = {
      errorType: “TEXT”;
      errorCode: string;
      errorMessage: string;
    };
    type ToastError = {
      errorType: “TOAST”;
      errorCode: string;
      errorMessage: string;
      toastShowDuration: number;
    }
    type AlertError = {
      errorType: “ALERT”;
      errorCode: string;
      errorMessage: string;
      onConfirm: () = > void;
    };

    type ErrorFeedbackType = TextError | ToastError | AlertError;

    const errorArr: ErrorFeedbackType[] = [
      { errorType: “TEXT”, errorCode: “100”, errorMessage: “텍스트 에러” },
      {
        errorType: “TOAST”,
        errorCode: “200”,
        errorMessage: “토스트 에러”,
        toastShowDuration: 3000,
      },
      {
        errorType: “ALERT”,
        errorCode: “300”,
        errorMessage: “얼럿 에러”,
        onConfirm: () => {},
      },
      {
        errorType: “TEXT”,
        errorCode: “999”,
        errorMessage: “잘못된 에러”,
        toastShowDuration: 3000, // Object literal may only specify known properties, and ‘toastShowDuration’ does not exist in type ‘TextError’
        onConfirm: () => {},
      },
      {
        errorType: “TOAST”,
        errorCode: “210”,
        errorMessage: “토스트 에러”,
        onConfirm: () => {}, // Object literal may only specify known properties, and ‘onConfirm’ does not exist in type ‘ToastError’
      },
      {
        errorType: “ALERT”,
        errorCode: “310”,
        errorMessage: “얼럿 에러”,
        toastShowDuration: 5000, // Object literal may only specify known properties, and ‘toastShowDuration’ does not exist in type ‘AlertError’
      },
    ];
    ```

- 4.3.3 식별할 수 있는 유니온의 판별자 선정
  - 식별할 수 있는 유니온 사용시 주의할 점: 팔별자는 유닛 타입으로 선언되어야 정상적으로 동작한다.
  - 유닛 타입(unit type): 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 타입 (ex. null, undefined, 리터럴 타입, true, 1 등)
  - ```jsx
    interface A {
      value: "a"; // unit type 
      answer: 1;
    }
    
    interface B {
      value: string; // not unit type 
      answer: 2;
    }
    
    interface C {
      value: Error; // instantiable type 
      answer: 3;
    }
    
    type Unions = A | B | C;
    function handle(param: Unions) (
      /** 판별자가 value일 때 */
      param.answer; // 1 | 2 | 3
      // 'a'가 리터럴 타임이므로 타입이 좁혀진다.
      // 단, 이는 string 타임에 포함되므로 param은 A 또는 B 타입으로 좁혀진다
      if (param.value === "a") {
      param.answer; // 1 | 2 return;
    
      // 유닛 타임이 아니거나 인스턴스화할 수 있는 타입일 경우 타입이 좁혀지지 않는다 
      if (typeof param.value === "string") {
    	param.answer; // 1 | 2 | 3 return;
      }
      if (param.value instanceof Error) {
        param.answer; // 1 | 2 | 3 return;
      }
      /** 판별자가 answer일 때 */
      param.value; // string | Error
      
      // 판별자가 유닛 타임이므로 타입이 좁혀진다
      if (param.answer === 1) {
        params.value; // 'a'
      }
    }
    ```

## 4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기
Exhaustiveness는 사전적으로 철저함, 완전함을 의미한다.
  - 정의: 모든 케이스에 대해 철저하게 타입을 검사하는 것. 모든 케이스에 대한 분기 처리를 하지 않았을 때, 컴파일 타임 에러가 발생하게 하는 것.
  - 모든 케이스에 대해 분기 처리를 해야만 유지보수 측면에서 안전하다고 생각되는 상황일 때 모든 케이스에 대한 타입 검사를 강제할 수 있다.
  - ```jsx
    ttype ProductPrice = "10000" | "20000" | "5000";

    const getProductName = (productPrice: ProductPrice): string => {
      if (productrice === "10000") return "배민상품권 1만 원";
      if (productprice === "2000") return "배민상품권 2만 원";
      // if (productprice ==="5000") return "배민상품권 5천 원";
    else { exhaustiveCheck(productPrice); // Error: Argument of type 'string' is not assign able to parameter of type 'never'
        return "배민상품권";
      }
    };
    
    const exhaustiveCheck = (param: never) => {
      throw new Error("type error!");`
    };
    // 이 함수를 위에 else문에 사용하면 앞의 조건문에서 모든 타입에 대한 분기 처리를 강제할 수 있다.
    ```
  - 예상치 못한 런타임 에러를 방지하거나 요구사항이 변경되었을 때 생길 수 있는 위험성을 줄일 수 있다.
