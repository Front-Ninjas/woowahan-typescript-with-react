## 타입 좁히기
### 타입 가드에 따라 분기 처리하기
타입 좁히기는 런타임에 조건문을 사용하여 타입을 검사하고 타입 범위를 좁혀주는 기능이다.
예를 들어 A | B 타입의 매개변수를 받아 A 일때와 B 일때는 구분해서 로직을 처리하고 싶을 때 
if문을 떠올리겠지만 컴파일 시 타입 정보는 모두 제거되어 런타임에 존재하지 않기 때문에 타입을 사용하여 조건을 만들 수는 없다.
컴파일을 해도 타입 정보가 사라지지 않는 방법을 사용해야 한다.
타입스크립트가 해당 변수를 타입 A로 추론하도록 유도하면서 런타임에서도 유효한 방법이 필요하다 이 때 타입 가드를 이용하면 된다.
js에서 타입가드는 typeof, instanceof, in과 같은 연산자를 사용하거나 제어문으로 특정 타입 값을 가질 수밖에 없는 상황을 유도하여 타입을 좁히는 것이다.
타입스크립트 뿐만 아니라 자바스크립트에서도 사용할 수 있는 문법으로 타입가드를 만들어야한다. 그래서 자바스크립트 연산자를 사용한다.
### typeof 연산자 활용하기
typeof는 자바스크립트 타입 시스템으로만 대응할 수 있어 복잡한 타입스크립트 타입을 검증할 수 없다. 원시 타입을 좁히는 용도로만 사용하면 된다.
### 인스턴스화된 객체 타입을 판별할 때 : istanceof 연산자 활용하기
```javascript
  interface Range { start : Date; end : Date; }
  interface DatePickerProps { selectedDates?: Date | Range;
  const DatePicker = ({selectedDates}: DatePickerProps) => const [selected, setSelected] = useState(convertToRange(selectedDates));
  convertToRange(selected?: Date | Range) : Range | undefined { return selected instanceof Date ? { start : selected, end : selected } : selected;
```
인스턴스화된 객체 타입을 판별하는 타입가드로 사용할 수 있다.

### 객체의 속성이 있는지 없는지에 따른 구분 : in 연산자 활용하기
**이건 기존의 속성에 새로운 속성들이 추가될 때 기존의 것과 새로운 것을 비교할 때 사용하는게 좋을 것 같다.**
```javascript
  interface BasicNoticeDialogProps { noticeTitle : string; noticeBody : string; }
  interface NoticeDialogWithCookieProps extends BasicNoticeDialogProps { cookieKey: string, noForADay?: boolean; neverAgain?: boolean }
  type NoticeDialogProps = BasicNoticeDialogProps | NoticeDialogWithCookieProps

  const NoticeDialog : React.FC<NoticeDialogProps> = (props) => {
    if ("cookieKey" in props) return <NoticeDialogWithCookie { ...props }
    return <NoticeDialogBase { ...props }
```
자바스크립트의 in 연산자는 런타임의 값만을 검사하지만 타입스크립트에서는 객체 타입에 속성이 존재하는지를 검사한다.

### is 연산자로 사용자 정의 타입 가드 만드렁 활용하기
참/거짓의 진릿값을 반환하면서 반환 타입을 타입 명제로 지정하게 되면 A(매개변수이름) is B(타입) A 반환 값이 참일 때 **매개변수의 타입을 B로 취급**한다.
```javascript
  type Singer = { sing: () => void };
  type Actor = { acting: () => void };
  
  const a: Singer = { sing: () => {} };
  const b: Singer = { sing: () => {} };
  const c: Singer = { sing: () => {} };
  const d: Actor = { acting: () => {} };
  const e: Actor = { acting: () => {} };
  const f: Actor = { acting: () => {} };
  
  const singerArr: Singer[] = [];
  const actorArr: Actor[] = [];
  const All: (Singer | Actor)[] = [a, b, c, d, e, f];
  const isSinger = (person: Singer | Actor): boolean => 'sing' in person;

  All.forEach((person) => {
    if (isSinger(person)) singerArr.push(person);
    else actorArr.push(person);
  });

  const isSinger = (person: Singer | Actor): person is Singer => 'sing' in person;

```
우리는 코드 흐름상 person이 isSinger(person)의 결과로 person이 Singer인걸 알 수 있지만 
타입스크립트는 그냥 boolean값으로 생각해서 singerArr은 singer 타입인데 왜 actor인 타입이 들어올 수 도있는 person을 singerArr에 넣으려고하지? 라고 생각한다.
그래서 isSinger의 반환값이 단순히 boolean값이 아니라 값이 참일 때 person이 Singer라는 의미를 가진 타입 명제를 반환값에 넣어 타입 추론을 도와줄 수 있다.
