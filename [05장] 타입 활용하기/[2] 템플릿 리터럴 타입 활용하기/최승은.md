# 5.2 템플릿 리터럴 타입 활용하기

타입스크립트에서는 특정 문자열만 허용하는 유니온 타입을 활용하여 변수의 타입을 제한할 수 있다.
이러한 방식은 잘못된 문자열 입력을 방지하고 자동 완성 기능을 제공하여 개발 생산성을 높이는 데 기여한다.

```ts
type HeaderTag = "h1" | "h2" | "h3" | "h4" | "h5";
```

하지만 유니온 타입만으로 표현하기 어려운 문자열 패턴을 타입으로 정의하려면 반복적인 선언이 필요해질 수 있다.
이를 해결하기 위해 **타입스크립트 4.1부터 “템플릿 리터럴 타입(Template Literal Type)”**이 도입되었다.

## 1. 템플릿 리터럴 타입이란?

템플릿 리터럴 타입은 타입 수준에서 문자열을 동적으로 생성할 수 있도록 해주는 기능이다.
이는 JavaScript의 템플릿 리터럴(`template ${value}`)과 유사한 문법을 사용하지만, 유형 검사를 위한 타입 시스템에서 동작한다.

```ts
type HeadingNumber = 1 | 2 | 3 | 4 | 5;
type HeaderTag = `h${HeadingNumber}`;
// "h1" | "h2" | "h3" | "h4" | "h5"
```

위 코드에서는 HeadingNumber 타입이 1 | 2 | 3 | 4 | 5로 정의되었고, 이를 활용하여 HeaderTag 타입을 “h” 접두사와 함께 자동으로 조합할 수 있다.
#### 즉, "h1" | "h2" | "h3" | "h4" | "h5" 같은 문자열을 자동으로 생성하는 것이다.

이처럼 템플릿 리터럴 타입을 사용하면 코드를 더욱 직관적이고 유지보수하기 쉽게 만들 수 있다.

## 2. 템플릿 리터럴 타입의 활용 예시

템플릿 리터럴 타입을 활용하면 다양한 경우에 유연하면서도 강력한 타입을 정의할 수 있다.

### 방향(Direction) 타입 정의하기

```ts
type Vertical = "top" | "bottom";
type Horizon = "left" | "right";

type Direction = Vertical | `${Vertical}${Capitalize<Horizon>}`;
// "top" | "topLeft" | "topRight" | "bottom" | "bottomLeft" | "bottomRight"
```

위 코드는 "top" 또는 "bottom"을 기본 방향으로 지정하고,
각 방향에 "left" 또는 "right"가 결합될 수 있도록 한다.

여기서 Capitalize<T> 유틸리티 타입을 사용하여 "left"와 "right"의 첫 글자를 대문자로 변환하여 "topLeft" 같은 형태로 만들어준다.

### API 응답 데이터의 상태 정의하기

API 응답 상태를 정의할 때도 템플릿 리터럴 타입을 활용할 수 있다.

```ts
type Status = "success" | "error" | "pending";
type RequestType = "GET" | "POST" | "DELETE";

type APIResponse<T extends RequestType> = `${T}_${Status}`;
// "GET_success" | "GET_error" | "GET_pending" | "POST_success" | ...
```

위 코드에서는 APIResponse<"GET">과 같이 사용하면 "GET_success" | "GET_error" | "GET_pending" 타입이 자동으로 생성된다.
#### 즉, 특정 API 요청 타입과 연관된 상태 값을 직관적인 문자열 패턴으로 제한할 수 있다.

## 3. 템플릿 리터럴 타입의 장점
1. 유니온 타입보다 직관적인 코드 작성 가능
   - 기존에는 "h1" | "h2" | "h3" | ... 같은 타입을 직접 작성해야 했지만,
템플릿 리터럴 타입을 사용하면 h${1 | 2 | 3 | 4 | 5}처럼 더 간결하고 직관적인 타입 선언이 가능하다.
2. 코드 수정 및 유지보수 용이
	 -	새로운 값이 추가될 때 기존 코드에서 수동으로 타입을 수정할 필요 없이 유니온 타입 값만 변경하면 자동으로 조합이 적용된다.
3. 더 강력한 타입 검증
   - 템플릿 리터럴 타입을 사용하면 의미적으로 잘못된 문자열을 방지할 수 있다.
	 - 예를 들어 APIResponse<"PUT">과 같이 정의된 요청 타입에 존재하지 않는 "PUT"을 넣으면, 타입 오류가 발생하여 실수를 방지할 수 있다.

## 4. 템플릿 리터럴 타입 사용 시 주의할 점
1.너무 많은 경우의 수를 생성하면 성능 저하 발생 가능
   - 유니온 타입의 조합이 많아지면 컴파일러가 모든 가능한 조합을 추론하는 데 시간이 오래 걸릴 수 있다.
   - 따라서 필요한 조합만 정의하거나, 여러 개의 타입을 나눠서 선언하는 것이 좋다.
2. 추론된 타입이 예상과 다를 수도 있음
   - 템플릿 리터럴 타입은 타입스크립트 컴파일러가 문자열을 조합하여 새로운 타입을 만들기 때문에, 예상과 다르게 동작할 수 있다.
   - 예를 들어, Capitalize<Lowercase<T>>처럼 여러 유틸리티 타입을 함께 사용할 경우 예상치 못한 결과가 나올 수도 있다.

## 5. 정리

템플릿 리터럴 타입은 유니온 타입을 보다 동적으로 활용할 수 있도록 해주는 기능이다. 이를 통해 더 직관적이고 유지보수하기 쉬운 타입을 선언할 수 있으며, 자동 완성과 타입 검사를 더욱 강화할 수 있다.
하지만 조합의 경우의 수가 너무 많아지면 컴파일 성능에 영향을 줄 수 있으므로 적절한 타입 분할이 필요하다.
