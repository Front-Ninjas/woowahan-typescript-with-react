#객체 타입

#object
객체의 범주는 원시 타입에 비해 굉장히 넓다.

#object
가급적 사용하지 말라고 권장 -> any타입과 유사하며 이는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문.
any타입과 다른점은 

#{} = 중괄호
객체 리터럴 방식으로 객체를 생성할 때 사용.
중괄호 안에 객체의 속성 타입을 지정해주는 식으로 사용. -> 타이핑되는 객체가 중괄호 안에서 선언된 구조와 일치해야 한다는 것을 의미.
{} 타입으로 지정된 객체에는 어떤 값도 속성으로 할당할 수 없다
빈 객체 타입을 지정하기 위해서는 {}보다는 유틸리티 타입으로 Record<string, nev-er>처럼 사용하는 것이 바람직.

#array
타입스크립트는 자바스크립트와 다르게 객체를 세분화하여 타입을 지정할 수 있는 타입 시스템을 갖고 있다.
각각의 객체에 타입을 지정할 수 있음.

자바스크립트의 배열 자료구조는 원소를 자유롭게 추가하고 제거 가능하며 타입 제한 없이 다양한 값을 다룬다. -> 하나의 배열 안에 숫자, 문자열과 같은 서로 다른 값이 혼재될 수 있다
--> 이런 쓰임은 타입스크립트가 추구하는 정적 타이핑 방향과 맞지 X

타입스크립트에서는 배열을 array라는 별도 타입으로 다룬다. -> 하나의 타입 값만 가질 수 있다는 점에서 자바스크립트 배열보다 엄격하다. 자바스크립트와 마찬가지로 원소 개수는 타입에 영향을 주지 X
또한 타입스크립트에서 배열 타입을 선언하는 방식은 1) rray 키워드로 선언 2) []를 이용해서 선언
튜플 타입에서 대괄호 선언 -> 튜플의 대활호 내부에는 선언 시점에 지정해준 타입과 값만 가능하다 원소 개수도 선언 당시 알 수 있다

#type과 interface 키워드
type은 모든 타입 선언 가능, interface는 원시적 타입 X, 객체 타입 가능
type은 확장 불가능, interface는 확장 가능
팀 내에서 사용할 때는 둘 다 사용하는 경우도 있지만, 확장가능하고 객체 지향 코드를 만들때는 interface 사용

type은 확장 불가능
type Person = {
  name: string;
  age: number;
}

type Person = { // ❗️Error: Duplicate identifier 'Person'.
  gender: string;
}
////////////////////////////////////////////
interface는 확장 가능
interface Person {
  name: string;
  age: number;
}

interface Person { // 선언적 확장
  gender: string;
}

const jieun: Person = {
  name: 'jieun',
  age: 27,
  gender: 'female'
}

#function
타입스크립에서도 함수를 별도 타입으로 지정할 수 있음.
자바스크립트에서는 function

자바스크립트에서는 함수를 작성할 때 function 키워드를 사용해서 작성한다
타입스크립트에서는 함수 자체의 타입을 명시할 때는 화살표 함수 방식으로만 호출 시그니처를 정의.

호출시그니처 : 타입스크립트에서 함수 타입을 정의할 때 사용하는 문법.
함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정된다 -> 매개변수와 반환 값의 타입을 정한다 (핵심)




