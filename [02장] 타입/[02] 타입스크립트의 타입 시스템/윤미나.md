# 2장 타입
---


## 2.2 타입스크립트의 타입 시스템
- 2.2.1 타입 애너테이션 방식
  - 타입 애너테이션: 변수, 상수 혹은 함수의 인자와 반환 값에 타입을 명시적으로 선언하여 어떤 타입 값이 저장될 것인지 컴파일러에 직접 알려주는 문법
    자바와 C#에서는 변수 앞에 데이터 타입을 작성한다. (int Num = 20; )
    타입스크립트는 변수 이름 뒤에 : type 구문을 붙여 데이터 타입을 명시한다. (let color: string = 'blue'; )
    
- 2.2.2 구조적 타이핑
  - 타입 시스템: 값이나 객체가 가지고 있는 하나의 구체적인 타입은 이름으로 구분되며 컴파일타임 이후에도 남아있다.
  - 구조적 타이핑: 타입스크립트는 구조로 타이블 구분함.

- 2.2.3 구조적 서브타이핑
  타입스크립트의 타입은 값의 집합으로 생각할 수 있다. 타입은 집합에 포함되는 값이고 특정 값은 많은 집합에 포함될 수 있다.
  타입스크립트에서는 특정 값이 string 또는 number 타입을 동시에 가질 수 있다.
  - 구조적 서브타이핑: 객체가 가지고 있는 속성 (프로퍼티)을 바탕으로 타입을 구분하는 것
    서로 다른 두 타입 간의 호환성은 오로지 타입 내부의 구조에 의해 결정된다.
    타입 A가 타입 B의 서브타입이라면 A 타입의 인스턴스는 B타입이 필요한 곳에 언제든지 위치할 수 있다. -> 타입이 계층 구조로부터 자유롭다.

- 2.2.4 자바스크립트를 닮은 타입스크립트
  명목적 타이핑을 채택한 언어에서는 이름으로 타입을 구분하기 때문에 구조가 같더라도 이르미 다르면 다른 타입으로 취급한다.
  타입의 동일성을 확인하는 과정에서 구조적 타이핑에 비해 조금 더 안전하다.
  ```jsx
  class Cat {
    String name;
      public void hit(){}
  }
  class Arrow {
    String name;
      public void hit(){}
  }

  public class Main{
    public static void main (String[] args){
      Arrow cat = new Cat(); // error: incompatible types: Cat cannot be converted to Arrow
      Cat arrow = new Arrow();  // error: incompatible types: Arrow cannot be converted to Cat
  }
  ```

  - 자바스크립트는 **덕 타이핑**을 기반으로 한다.
  
  (덕 타이핑: 어떤 함수의 매개변숫값이 올바르게 주어진다면 그 값이 어떻게 만들어졋는지 신경 쓰지 않고 사용한다는 개념
  어떤 타입에 부합하는 변수와 메서드를 가질 경우 해다 타입에 속하는 것으로 간주하는 방식 )

  타입스크립트는 자바스크립트의 특징을 받아들여 객체나 함수가 가진 구조적 특징을 기반으로 타이핑하는 방식을 택했다.

  -> 쉬운 사용성과 안전성 사이의 균형, 높은 편리성

  |  | 타입 검사 시점 | 사용 |
  | --- | --- | --- |
  | 덕 타이핑 | 런타임 | 동적 타이핑 |
  | 구조적 타이핑 | 컴파일타임 (의 타입체커가 타입 검사) | 정적 타이핑 | 
   
  
- 2.2.5 구조적 타이핑의 결과
  ```jsx
  interface Cube {
    width: number;
    heigth: number;
    depth: number;
  }
  function addLines(c: Cube){
    let total = 0;
    for (const axis of Object.keys(c)){
      const length = c[axis];
      total += length;
    }
  }
  ```
  Cube 인터페이스의 모든 필드는 number 타입을 가지기 때문에 c[axis]도 당연히 number 타입일 것이라고 예측한다.
  그러나 c에 들어올 객체는 Cube의 width, height, depth 외에도 어떤 속성이든 가질 수 있기 때문에 c[axis]의 타입이 string 일 수도 있어 에러가 발생한다.

  타입스크립트 구조적 타이핑의 특징으로 Cube 타입 값이 들어갈 곳에 name (string) 같은 추가 속성을 가진 객체도 할당할 수 있기 때문에 발생하는 문제이다.
  - 해결방법: 유니온 (타입스크립트에 명목적 타이핑 언어의 특징을 가미하여 식별할 수 있는 방법)

- 2.2.6 타입스크립트의 점진적 타입 확인
  - 타입스크립트는 **점지적으로 타입을 확인하는 언어**이다.
    - 점진적 타입 검사: 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식
      |  | 타입 지정 유무에 따른 결과  |
      |--- | --- |
      | 타입을 지정한 변수와 표현식 | 정적 타입 검사 |
      | 타입 선언 생략한 변수와 표현식 | 동적 타입 검사, 암시적 타입변환이 일어남 |

  - 모든 변수와 표현식의 타입을 컴파일타임에 검사하지 않아도 되기 때문에 타입이 올바르게 정해지지 않으면 런타임에서 에러가 발생하기도 한다.


- 2.2.7 자바스크립트 슈퍼셋으로서의 타입스크립트
  - 타입스크립트는 기존 자바스크립트 코드에 **정적인 타이핑**을 추가한 것으로 자바스크립트의 **상위 집합**이다.
    - 모든 자바스크립트 코드는 타입스크립트라 볼 수 있다.
    - 모든 타입스크립트 코드는 자바스크립트 코드라고 할 수 없다.

- 2.2.8 값 vs 타입
  - 값: 프로그램이 처리하기 위해 메모리에 저장하는 모든 데이터 (문자열, 숫자, 변수, 매개변수, 객체, 함수 등)
    - 타입스크립트 문법인 type으로 선언한 내용은 자바스크리비트 런타임에서 제거되기 때문에 값 공간과 타입 공간은 서로 충돌하지 않는다.
  - 값과 타입은 타입스크립트에서 별도의 네임스페이스에 존재한다.
  - **구조 분해 할당**: 배열이나 객체의 속성을 개별 변수로 분해하여 그 값을 변수에 할당하는 것
    ```jsx
    function email({person, subject, body}:{
      person: Person;
      subject: string;
      body: string;
    }) {
    // ...
    }
    ```
  - 타입스크립트에서 클래스는 타입 애너테이션으로 사용할 수 있지만 런타임에서 객체로 변환되어 자바스크립트의 값으로 사용되는 특성을 가지고 있다.
  - | 키워드 | 값 | 타입 |
    |---|---|---|
    | class | Y | Y |
    | const, let, var | Y | N |
    | enum | Y | Y |
    | function | Y | N |
    | interface | N | Y |
    | type | N | Y |
    | namespace | Y | N |

  - 트리쉐이킹: 자바스크립트, 타입스크립트에서 사용하지 않는 코드를 삭제하는 방식
    최신 애플리케이션 개발 환경에서 웹팩, 롤업 같은 모듈 번들러를 사용하여 번들링 작업을 수행할 때 사용하지 않는 코드를 자동으로 삭제한다.

- 2.2.9 타입을 확인하는 방법
  typeof, instanceof, 타입 단언을 사용하여 타입을 확인한다.
  - typeof: 연산하기 저네 피연산자의 데이터 타입을 나타내는 문자열을 반환 (반환값: 7가지 기본 데이터 타입, Function, 호스트 객체, object 객체)
    - 값에서 사용된 typeof: 자바스크립트 런타임의 typeof 연산자
    - 타입에서 사용된 typeof: 타입스크립트 타입을 반환
    - ```jsx
      class Developer {
        name: String;
        sleepingTime: number;
      
        constructor(name: string, sleepingTime: number){
          this.name = name;
          this.sleepingTime = sleepingTime;
        }
      }
      
      const d = typeof Developer;  // 값이 function
      type T = typeof Developer;  // 타입이 typeof Developer
      // type T에 할당된 eveloper는 인스턴스 타입이 아니라 new 키워드를 사용할때 볼 수 있는 생성자 함수이기 때문

      ```
  - 타입 단언: as 키워드를 사용하여 타입을 강제하는 것.
    - 개발자가 해당 값의 타입을 더 잘 파악할 수 있을 때 사용되며, 강제 형 변환과 유사한 기능을 제공
    - 컴파일 단계에서 타입 단언이 형 변환을 강제할 수 있지만 런타임에서는 효력이 없다. (타입스크립트의 타입 시스템과 문법은 컴파일 단계에서 제거되기 때문)

  - 타입 가드: 특정 조거늘 검사해서 타이블 정제하고 타입 안정성을 높이는 패턴
