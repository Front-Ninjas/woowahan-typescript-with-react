# 7장 비동기 호출

## 7.1 API 요청

### 7.1.1 fetch로 API 요청하기
비동기 함수인 fetch를 사용하여 API를 요청할 때 비동기 호출 코드를 변경해야할 경우
  - 새로운 API 요청 정책이 추가될때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다.

### 7.1.2 서비스 레이어로 분리하기
코드가 변경될 수 있다는 것을 감안한다면, 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 한다.
 - 쿼리 매개변수, 커스텀 헤더 추가, 쿠키 읽어 토큰 집어넣기 등 다야한 API 정책이 추가될 경우 이를 모두 구현하는 것은 번거롭다.

### 7.1.3 Axios 활용하기
fetch는 내장 라이브러리이기 떄문에 따로 설치할 필요가 없지만 많은 기능을 사용하려면 직접 구현해서 사용해야 한다.
- 번거로움을 해결하기 위해 fetch 함수를 직접 쓰는 대신 **Axios** 라이브러리를 사용한다.
- API Entry가 2개 이상일 경우 Base URL과 2개 이상의 API를 요청하는 인스턴스를 따로 구성해야 한다.
- ```jsx
  import axios, { AxiosInstance } from "axios";

  const defaultConfig = {};
  
  const apiRequester: AxiosInstance = axios.create(defaultConfig);
  const orderApiRequester: AxiosInstance = axios.create({
    baseURL: "https://api.baemin.or/",
    ...defaultConfig,
  });
  const orderCartApiRequester: AxiosInstance = axios.create({
    baseURL: "https://cart.baemin.order/",
    ...defaultConfig,
  });
  ```

### 7.1.4 Axios 인터셉터 사용하기
각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수도 있다.
  - 이터셉터 기능 사용: requester에 따라 비동기 호출 내용을 추가해서 처리
  - API 에러 처리할 때 하나의 에러 객체러 묶어서 처리

- 기본 API 클래스: 실제 호출 부분 구성
```jsx
import axios, { AxiosPromise } from "axios";

// 임시 타이핑
export type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";

export type HTTPHeaders = any;

export type HTTPParams = unknown;

//
class API {
  readonly method: HTTPMethod;

  readonly url: string;

  baseURL?: string;

  headers?: HTTPHeaders;

  params?: HTTPParams;

  data?: unknown;

  timeout?: number;

  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url;
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();
    // 만약 `withCredential`이 설정된 API라면 아래 같이 인터셉터를 추가하고, 아니라면 인터셉터 를 사용하지 않음
    if (this.withCredentials) {
      http.interceptors.response.use(
        (response) => response,
        (error) => {
          if (error.response && error.response.status === 401) {
            /* 에러 처리 진행 */
          }
          return Promise.reject(error);
        }
      );
    }
    return http.request({ ...this });
  }
}

export default API;
```
- API 호출을 위한 래퍼를 빌더 패턴으로 만들기
```jsx
import API, { HTTPHeaders, HTTPMethod, HTTPParams } from "./7.1.4-2";

const apiHost = "";

class APIBuilder {
  private _instance: API;

  constructor(method: HTTPMethod, url: string, data?: unknown) {
    this._instance = new API(method, url);
    this._instance.baseURL = apiHost;
    this._instance.data = data;
    this._instance.headers = {
      "Content-Type": "application/json; charset=utf-8",
    };
    this._instance.timeout = 5000;
    this._instance.withCredentials = false;
  }

  static get = (url: string) => new APIBuilder("GET", url);

  static put = (url: string, data: unknown) => new APIBuilder("PUT", url, data);

  static post = (url: string, data: unknown) =>
    new APIBuilder("POST", url, data);

  static delete = (url: string) => new APIBuilder("DELETE", url);

  baseURL(value: string): APIBuilder {
    this._instance.baseURL = value;
    return this;
  }

  headers(value: HTTPHeaders): APIBuilder {
    this._instance.headers = value;
    return this;
  }

  timeout(value: number): APIBuilder {
    this._instance.timeout = value;
    return this;
  }

  params(value: HTTPParams): APIBuilder {
    this._instance.params = value;
    return this;
  }

  data(value: unknown): APIBuilder {
    this._instance.data = value;
    return this;
  }

  withCredentials(value: boolean): APIBuilder {
    this._instance.withCredentials = value;
    return this;
  }

  build(): API {
    return this._instance;
  }
}

export default APIBuilder;
```
- 실제 사용하기
```jsx
import APIBuilder from "./7.1.4-3";

// ex
type Response<T> = { data: T };
type JobNameListResponse = string[];

const fetchJobNameList = async (name?: string, size?: number) => {
  const api = APIBuilder.get("/apis/web/jobs")
    .withCredentials(true) // 이제 401 에러가 나는 경우, 자동으로 에러를 탐지하는 인터셉터를 사용하게 된다
    .params({ name, size }) // body가 없는 axios 객체도 빌더 패턴으로 쉽게 만들 수 있다
    .build();
  const { data } = await api.call<Response<JobNameListResponse>>();
  return data;
};
```


### 7.1.5 API 응답 타입 지정하기

### 7.1.6 뷰 모델(View Model) 사용하기

### 7.1.7 Superstruct를 사용해 런타임에서 응답 타입 검증하기

### 7.1.8 실제 API 응답 시의 Superstruct 활용 사례
