# 7장 비동기 호출

## 7.1 API 요청

### 7.1.1 fetch로 API 요청하기
비동기 함수인 fetch를 사용하여 API를 요청할 때 비동기 호출 코드를 변경해야할 경우
  - 새로운 API 요청 정책이 추가될때마다 계속해서 비동기 호출 코드를 수정해야 하는 번거로움이 발생한다.

### 7.1.2 서비스 레이어로 분리하기
코드가 변경될 수 있다는 것을 감안한다면, 비동기 호출 코드는 컴포넌트 영역에서 분리되어 다른 영역(서비스 레이어)에서 처리되어야 한다.
 - 쿼리 매개변수, 커스텀 헤더 추가, 쿠키 읽어 토큰 집어넣기 등 다야한 API 정책이 추가될 경우 이를 모두 구현하는 것은 번거롭다.

### 7.1.3 Axios 활용하기
fetch는 내장 라이브러리이기 떄문에 따로 설치할 필요가 없지만 많은 기능을 사용하려면 직접 구현해서 사용해야 한다.
- 번거로움을 해결하기 위해 fetch 함수를 직접 쓰는 대신 **Axios** 라이브러리를 사용한다.
- API Entry가 2개 이상일 경우 Base URL과 2개 이상의 API를 요청하는 인스턴스를 따로 구성해야 한다.
- ```jsx
  import axios, { AxiosInstance } from "axios";

  const defaultConfig = {};
  
  const apiRequester: AxiosInstance = axios.create(defaultConfig);
  const orderApiRequester: AxiosInstance = axios.create({
    baseURL: "https://api.baemin.or/",
    ...defaultConfig,
  });
  const orderCartApiRequester: AxiosInstance = axios.create({
    baseURL: "https://cart.baemin.order/",
    ...defaultConfig,
  });
  ```

### 7.1.4 Axios 인터셉터 사용하기
- 각각의 requester는 서로 다른 역할을 담당하는 다른 서버이기 때문에 requester별로 다른 헤더를 설정해줘야 하는 로직이 필요할 수도 있다.
  - 인터셉터 기능 사용: requester에 따라 비동기 호출 내용을 추가해서 처리
  - API 에러 처리할 때 하나의 에러 객체러 묶어서 처리

- 인터셉터: 요청(Request)이나 응답(Response)을 가로채서 특정 로직을 수행하는 기능
  - 주로 Axios와 같은 HTTP 클라이언트에서 인터셉터를 사용하여 요청/응답을 가로채고 조작하는 데 활용
- 기본 API 클래스: 실제 호출 부분 구성
```jsx
import axios, { AxiosPromise } from "axios";

// 임시 타이핑
export type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";

export type HTTPHeaders = any;

export type HTTPParams = unknown;

//
class API {
  readonly method: HTTPMethod;

  readonly url: string;

  baseURL?: string;

  headers?: HTTPHeaders;

  params?: HTTPParams;

  data?: unknown;

  timeout?: number;

  withCredentials?: boolean;

  constructor(method: HTTPMethod, url: string) {
    this.method = method;
    this.url = url;
  }

  call<T>(): AxiosPromise<T> {
    const http = axios.create();
    // 만약 `withCredential`이 설정된 API라면 아래 같이 인터셉터를 추가하고, 아니라면 인터셉터 를 사용하지 않음
    if (this.withCredentials) {
      http.interceptors.response.use(
        (response) => response,
        (error) => {
          if (error.response && error.response.status === 401) {
            /* 에러 처리 진행 */
          }
          return Promise.reject(error);
        }
      );
    }
    return http.request({ ...this });
  }
}

export default API;
```
- API 호출을 위한 래퍼를 빌더 패턴으로 만들기
```jsx
import API, { HTTPHeaders, HTTPMethod, HTTPParams } from "./7.1.4-2";

const apiHost = "";

class APIBuilder {
  private _instance: API;

  constructor(method: HTTPMethod, url: string, data?: unknown) {
    this._instance = new API(method, url);
    this._instance.baseURL = apiHost;
    this._instance.data = data;
    this._instance.headers = {
      "Content-Type": "application/json; charset=utf-8",
    };
    this._instance.timeout = 5000;
    this._instance.withCredentials = false;
  }

  static get = (url: string) => new APIBuilder("GET", url);

  static put = (url: string, data: unknown) => new APIBuilder("PUT", url, data);

  static post = (url: string, data: unknown) =>
    new APIBuilder("POST", url, data);

  static delete = (url: string) => new APIBuilder("DELETE", url);

  baseURL(value: string): APIBuilder {
    this._instance.baseURL = value;
    return this;
  }

  headers(value: HTTPHeaders): APIBuilder {
    this._instance.headers = value;
    return this;
  }

  timeout(value: number): APIBuilder {
    this._instance.timeout = value;
    return this;
  }

  params(value: HTTPParams): APIBuilder {
    this._instance.params = value;
    return this;
  }

  data(value: unknown): APIBuilder {
    this._instance.data = value;
    return this;
  }

  withCredentials(value: boolean): APIBuilder {
    this._instance.withCredentials = value;
    return this;
  }

  build(): API {
    return this._instance;
  }
}

export default APIBuilder;
```
- 실제 사용하기
```jsx
import APIBuilder from "./7.1.4-3";

// ex
type Response<T> = { data: T };
type JobNameListResponse = string[];

const fetchJobNameList = async (name?: string, size?: number) => {
  const api = APIBuilder.get("/apis/web/jobs")
    .withCredentials(true) // 이제 401 에러가 나는 경우, 자동으로 에러를 탐지하는 인터셉터를 사용하게 된다
    .params({ name, size }) // body가 없는 axios 객체도 빌더 패턴으로 쉽게 만들 수 있다
    .build();
  const { data } = await api.call<Response<JobNameListResponse>>();
  return data;
};
```
- 보일러플레이트(Boilerplate) 코드: 어떤 기능을 사용할 때 반복적으로 사용되는 기본적인 코드
  - API 호출하기 위한 기본적인 설정과 인터셉터 등을 설정하는 부분을 보일러플레이트 코드로 간주할 수 있다.

### 7.1.5 API 응답 타입 지정하기
같은 서버에서 오는 응답의 형태는 대체로 통일되어 있어 API의 응답 값은 하나의 Response 타입으로 묶일 수 있다.
- 서버에서 오는 응답을 통일해줄 때 Response 타입은 apiRequester가 모르게 관리되어야 한다.
```jsx
import { AxiosPromise } from "axios";
import {
  FetchCartResponse,
  PostCartRequest,
  PostCartResponse,
  apiRequester,
} from "./7.1.3-1";

export interface Response<T> {
  data: T;
  status: string;
  serverDateTime: string;
  errorCode?: string; // FAIL, ERROR errorMessage?: string; // FAIL, ERROR
}
const fetchCart = (): AxiosPromise<Response<FetchCartResponse>> =>
  apiRequester.get<Response<FetchCartResponse>>("cart");

const postCart = (
  postCartRequest: PostCartRequest
): AxiosPromise<Response<PostCartResponse>> =>
  apiRequester.post<Response<PostCartResponse>>("cart", postCartRequest);
```

- API 응답 값 중에서는 하나의 API 서버에서 다른 API 서버로 넘겨주기만 하는 값도 존재할 수 있다.
  - 해당 값에 어떤 응답이 들어있는지 알 수 없거나 값의 형식이 달라지더라도 로직에 영향을 주지 않는 경우에는 unknown 타입을 사용하여 알 수 없는 값임을 표현한다.
  ```jsx
  interface response {
  data: {
    cartItems: CartItem[];
    forPass: unknown;// 언제든지 변경 될 수 있으므로, forPass 내의 값을 사용하지 않아야한다.
  };
  ```
  
### 7.1.6 뷰 모델(View Model) 사용하기
API 응답은 변할 가능성이 크다. 뷰 모델을 사용하며 API 변경에 따른 범위를 한정해줘야 한다.

### 7.1.7 Superstruct를 사용해 런타임에서 응답 타입 검증하기

### 7.1.8 실제 API 응답 시의 Superstruct 활용 사례
