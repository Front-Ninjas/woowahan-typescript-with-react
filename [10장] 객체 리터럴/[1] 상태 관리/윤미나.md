# 10장 상태 관리
## 10.1 상태관리

### 10.1.1 상태
- 리액트 애플리케이션에서의 '상태': 렌더링에 영향을 줄 수있는 동적인 데이터 값 또는 정보를 담은 순수 자바스크립트 객체.
- 지역 상태
  - useState, useReducer 주로 사용
  - ex) 체크박스의 체크 여부, 폼의 입력값 등
- 전역 상태
  - 정의: 앱 전체에서 공유하는 상태 (Prop drilling 문제 해결 가능)
- 서버 상태
  - 정의: 외부 서버에 저장해야하는 상태
  - react-query, SWR 같은 외부 라이브러리 사용하여 관리하기도 함.
  - ex) 사용자 정보, 글 목록, 로딩 여부, 에러 상태 등

### 10.1.2 상태를 잘 관리하기 위한 가이드
유지보수 및 성능 관점에서 상태의 개수를 최소화하는 것이 바람직함.

값을 상태로 정의할 때의 고려사항
- **시간이 지나도 변하지 않는 않는 값** -> 객체 참조 동일성을 유지하는 방법 사용
  - 컴포넌트 라이프사이클 내에서 마운트될 때 인스턴스가 생성되고, 렌더링 될 때마다 동일한 객체 참조가 유지되도록 구현
  - 방법: **메모제이션 useMome** 활용(컴포넌트 마운트될 때만 객체 인스턴스 생성. 이후 렌더링에서는 이전 인스턴스 재활용)
    - 성능 개선을 위해 나중에 추가하는 것이 적절함  (메모리 확보를 위해 이전 메모제이션 데이터가 삭제될 수 있음)
    - useState 초기값만 지정하는 방법
      - 콜백을 지정하는 방식(=지연 초기화 방식) : useState(() => new Store())
    - useRef를 사용하는 방법 (권장)
      ```jsx
      const store = useRef<Store>(null);
      if(!store.current) {
        store.current = new Store()l
      }
      ```

- **파생된 값은 상태가 아니다.**
  - props이거나 기존 상태에서 계산될 수 있는 값은 상태가 아님.
  - SSOT : 어떠한 데이터도 단 하나의 출처에서 생성하고 수정해야 한다는 원칙
    - 파생된 값을 상태로 관리하게 되면 기존 출처와는 다른 새로운 출처에서 관리하게 되는 것 -> 해당 데이터의 정확성과 일관성을 보장하기 어려움
    - 방법: 가까운 공통 부모 컴포넌트로 상태를 끌어올리기

- **useState vs useReducer 어떤 것을 사용해야 할까?**
  - useReducer 권장하는 경우
    - 다수의 하위 필드를 포함하고 있는 복잡한 상태로 로직을 다룰 때
    - 다음 상태가 이전 상태에 의존적일 때
  - useReducer는 '무엇을 변경할지'와 '어떻게 변경할지'를 분리하여 dispatch를 통해 어떤 작업을 할지 액션으로 넘기고 reducer 함수 내에서 상태를 업데이트하는 방식을 정의
    - 복잡한 상태 로직 숨기고 안전성 높일 수 있음.
   
### 10.1.3 전역 상태 관리와 상태 관리 라이브러리
상태는 사용하는 곳과 최대한 가까워야 하며 사용 범위를 제한해야만 한다.
- 전역 상태로 사용하는 방법
  - context API + useState 또는 useReducer
  - 외부 상태 관리 라이브러리 (Redux, MobX, Recoil 등)

- context API: 다른 컴포넌트들과 데이터를 쉽게 공유하기 위한 목적으로 제공되는 API
  - Prop Drilling 문제를 해결하기 위한 도구
  - 전역적으로 공유해야하는 데이터를 컨텍스트로 제공하고 해당 컨텍스트를 구독한 컴포넌트에서만 데이터를 읽을 수 있게 된다.
  - 팁: 유틸리티 함수를 정의하여 더 간단한 코드로 컨텍스트와 훅을 생성하는 것
    - ex) createContext 라는 유틸리티 함수 정의
  - 대규모 또는 성능이 중요한 애플리케이션에서는 권장 X
     - 이유: context provider의 props로 주입된 값이나 참조가 변경될 때마다 context를 구독하고 있는 모든 컴포넌트가 리렌더링 되기 때문
     - 이유: 전역 상태가 많아질수록 불필요한 리렌더링과 상태의 복잡도가 증가하기 때문 

